<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TCP ‚Äî Traffic Control Planner</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚óÜ</text></svg>">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body, #root { width: 100%; height: 100%; overflow: hidden; }
  body { background: #0f1117; font-family: 'JetBrains Mono', monospace; }
  #loading { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #0f1117; color: #f59e0b; font-family: 'JetBrains Mono', monospace; z-index: 9999; transition: opacity 0.3s; }
  #loading .logo { font-size: 48px; margin-bottom: 16px; animation: pulse 1.5s ease-in-out infinite; }
  #loading .title { font-size: 18px; font-weight: 700; letter-spacing: 3px; margin-bottom: 8px; }
  #loading .sub { font-size: 11px; color: #94a3b8; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
</style>
</head>
<body>
<div id="loading">
  <div class="logo">‚óÜ</div>
  <div class="title">TCP</div>
  <div class="sub">Loading Traffic Control Planner‚Ä¶</div>
</div>
<div id="root"></div>
<script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
const { useState, useRef, useEffect, useCallback, useMemo } = React;

// ‚îÄ‚îÄ‚îÄ CONSTANTS & DATA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const GRID_SIZE = 20;
const MIN_ZOOM = 0.1;
const MAX_ZOOM = 5;

const COLORS = {
  bg: "#0f1117",
  panel: "#1a1d27",
  panelBorder: "#2a2d3a",
  accent: "#f59e0b",
  accentHover: "#fbbf24",
  accentDim: "rgba(245,158,11,0.15)",
  text: "#e2e8f0",
  textMuted: "#94a3b8",
  textDim: "#64748b",
  canvas: "#1e2028",
  grid: "rgba(255,255,255,0.03)",
  road: "#3a3d4a",
  roadLine: "#f59e0b",
  roadLineWhite: "#ffffff",
  laneMarking: "rgba(255,255,255,0.6)",
  danger: "#ef4444",
  success: "#22c55e",
  info: "#3b82f6",
  selected: "#818cf8",
};

const SIGN_CATEGORIES = {
  regulatory: {
    label: "Regulatory",
    color: "#ef4444",
    signs: [
      { id: "stop", label: "STOP", shape: "octagon", color: "#ef4444", textColor: "#fff" },
      { id: "yield", label: "YIELD", shape: "triangle", color: "#ef4444", textColor: "#fff" },
      { id: "speed25", label: "25", shape: "rect", color: "#fff", textColor: "#111", border: "#111" },
      { id: "speed35", label: "35", shape: "rect", color: "#fff", textColor: "#111", border: "#111" },
      { id: "speed45", label: "45", shape: "rect", color: "#fff", textColor: "#111", border: "#111" },
      { id: "noentry", label: "‚äò", shape: "circle", color: "#ef4444", textColor: "#fff" },
      { id: "oneway", label: "ONE WAY ‚Üí", shape: "rect", color: "#111", textColor: "#fff" },
      { id: "donotenter", label: "DO NOT ENTER", shape: "rect", color: "#ef4444", textColor: "#fff" },
    ],
  },
  warning: {
    label: "Warning",
    color: "#f59e0b",
    signs: [
      { id: "roadwork", label: "‚ö† ROAD WORK", shape: "diamond", color: "#f97316", textColor: "#111" },
      { id: "flagahead", label: "FLAGGER", shape: "diamond", color: "#f97316", textColor: "#111" },
      { id: "merge", label: "MERGE", shape: "diamond", color: "#f97316", textColor: "#111" },
      { id: "curve", label: "‚Ü∫ CURVE", shape: "diamond", color: "#f97316", textColor: "#111" },
      { id: "narrow", label: "NARROW", shape: "diamond", color: "#f97316", textColor: "#111" },
      { id: "bump", label: "BUMP", shape: "diamond", color: "#f97316", textColor: "#111" },
      { id: "pedestrian", label: "üö∂", shape: "diamond", color: "#f97316", textColor: "#111" },
      { id: "signal", label: "üö¶", shape: "diamond", color: "#f97316", textColor: "#111" },
    ],
  },
  temporary: {
    label: "Temp Traffic Control",
    color: "#f97316",
    signs: [
      { id: "roadclosed", label: "ROAD CLOSED", shape: "rect", color: "#f97316", textColor: "#111" },
      { id: "detour", label: "DETOUR ‚Üí", shape: "rect", color: "#f97316", textColor: "#111" },
      { id: "laneclosed", label: "LANE CLOSED", shape: "rect", color: "#f97316", textColor: "#111" },
      { id: "endwork", label: "END ROAD WORK", shape: "rect", color: "#f97316", textColor: "#111" },
      { id: "slowtraffic", label: "SLOW TRAFFIC", shape: "rect", color: "#f97316", textColor: "#111" },
      { id: "workzone", label: "WORK ZONE", shape: "rect", color: "#f97316", textColor: "#111" },
    ],
  },
  guide: {
    label: "Guide & Info",
    color: "#22c55e",
    signs: [
      { id: "parking", label: "P", shape: "rect", color: "#3b82f6", textColor: "#fff" },
      { id: "hospital", label: "H", shape: "rect", color: "#3b82f6", textColor: "#fff" },
      { id: "info", label: "i", shape: "rect", color: "#3b82f6", textColor: "#fff" },
      { id: "interstate", label: "I-95", shape: "shield", color: "#3b82f6", textColor: "#fff" },
    ],
  },
};

const DEVICES = [
  { id: "cone", label: "Traffic Cone", icon: "‚ñ≤", color: "#f97316" },
  { id: "barrel", label: "Drum/Barrel", icon: "‚óâ", color: "#f97316" },
  { id: "barrier", label: "Barrier", icon: "‚ñ¨", color: "#fbbf24" },
  { id: "delineator", label: "Delineator", icon: "‚îÇ", color: "#f97316" },
  { id: "arrow_board", label: "Arrow Board", icon: "‚üπ", color: "#fbbf24" },
  { id: "message_sign", label: "Message Sign", icon: "‚ñ£", color: "#fbbf24" },
  { id: "flagman", label: "Flagger", icon: "üè¥", color: "#22c55e" },
  { id: "temp_signal", label: "Temp Signal", icon: "üö¶", color: "#ef4444" },
  { id: "crashcush", label: "Crash Cushion", icon: "‚üê", color: "#ef4444" },
  { id: "water_barrel", label: "Water Barrel", icon: "‚äö", color: "#3b82f6" },
];

const ROAD_TYPES = [
  { id: "2lane", label: "2-Lane Road", lanes: 2, width: 80 },
  { id: "4lane", label: "4-Lane Road", lanes: 4, width: 150 },
  { id: "6lane", label: "6-Lane Divided", lanes: 6, width: 220 },
  { id: "highway", label: "Highway", lanes: 4, width: 180 },
];

const TOOLS = [
  { id: "select", label: "Select", icon: "‚Üñ", shortcut: "V" },
  { id: "pan", label: "Pan", icon: "‚úã", shortcut: "H" },
  { id: "road", label: "Road", icon: "‚îÅ", shortcut: "R" },
  { id: "sign", label: "Sign", icon: "‚¨°", shortcut: "S" },
  { id: "device", label: "Device", icon: "‚ñ≤", shortcut: "D" },
  { id: "zone", label: "Work Zone", icon: "‚ñ®", shortcut: "Z" },
  { id: "text", label: "Text", icon: "T", shortcut: "T" },
  { id: "measure", label: "Measure", icon: "üìè", shortcut: "M" },
  { id: "arrow", label: "Arrow", icon: "‚Üí", shortcut: "A" },
  { id: "erase", label: "Erase", icon: "‚úï", shortcut: "X" },
];

// ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const uid = () => Math.random().toString(36).slice(2, 10);

const snapToGrid = (v, grid) => Math.round(v / grid) * grid;

const dist = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

const angleBetween = (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1);

async function geocodeAddress(query) {
  try {
    const response = await fetch(
      `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?f=json&singleLine=${encodeURIComponent(query)}&maxLocations=5`
    );
    if (!response.ok) return [];
    const data = await response.json();
    const candidates = Array.isArray(data?.candidates) ? data.candidates : [];
    return candidates.map((candidate) => ({
      lat: String(candidate?.location?.y ?? ""),
      lon: String(candidate?.location?.x ?? ""),
      display_name: candidate?.address || "",
      address: {
        road: candidate?.address || "",
      },
    }));
  } catch {
    return [];
  }
}

function formatSearchPrimary(result) {
  const address = result?.address;
  if (address) {
    const street = [address.house_number, address.road || address.pedestrian || address.footway || address.cycleway]
      .filter(Boolean)
      .join(" ");
    const locality = address.city || address.town || address.village || address.hamlet || address.county;
    const region = address.state || address.state_district;
    const localityRegion = [locality, region].filter(Boolean).join(", ");
    if (street && localityRegion) return `${street}, ${localityRegion}`;
    if (street) return street;
  }
  return result?.display_name || "";
}

function drawRoadSegment(ctx, road, zoom) {
  const { x1, y1, x2, y2, width, lanes, type } = road;
  const angle = angleBetween(x1, y1, x2, y2);
  const perpAngle = angle + Math.PI / 2;
  const hw = width / 2;

  // Road surface
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(x1 + Math.cos(perpAngle) * hw, y1 + Math.sin(perpAngle) * hw);
  ctx.lineTo(x2 + Math.cos(perpAngle) * hw, y2 + Math.sin(perpAngle) * hw);
  ctx.lineTo(x2 - Math.cos(perpAngle) * hw, y2 - Math.sin(perpAngle) * hw);
  ctx.lineTo(x1 - Math.cos(perpAngle) * hw, y1 - Math.sin(perpAngle) * hw);
  ctx.closePath();
  ctx.fillStyle = COLORS.road;
  ctx.fill();
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 2;
  ctx.stroke();

  // Edge lines
  ctx.strokeStyle = COLORS.roadLineWhite;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x1 + Math.cos(perpAngle) * hw, y1 + Math.sin(perpAngle) * hw);
  ctx.lineTo(x2 + Math.cos(perpAngle) * hw, y2 + Math.sin(perpAngle) * hw);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x1 - Math.cos(perpAngle) * hw, y1 - Math.sin(perpAngle) * hw);
  ctx.lineTo(x2 - Math.cos(perpAngle) * hw, y2 - Math.sin(perpAngle) * hw);
  ctx.stroke();

  // Lane markings
  const laneWidth = width / lanes;
  for (let i = 1; i < lanes; i++) {
    const offset = -hw + i * laneWidth;
    const lx1 = x1 + Math.cos(perpAngle) * offset;
    const ly1 = y1 + Math.sin(perpAngle) * offset;
    const lx2 = x2 + Math.cos(perpAngle) * offset;
    const ly2 = y2 + Math.sin(perpAngle) * offset;

    if (i === lanes / 2 && type !== "2lane") {
      // Center double yellow
      ctx.strokeStyle = COLORS.roadLine;
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      const off2 = 3;
      ctx.beginPath();
      ctx.moveTo(lx1 + Math.cos(perpAngle) * off2, ly1 + Math.sin(perpAngle) * off2);
      ctx.lineTo(lx2 + Math.cos(perpAngle) * off2, ly2 + Math.sin(perpAngle) * off2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(lx1 - Math.cos(perpAngle) * off2, ly1 - Math.sin(perpAngle) * off2);
      ctx.lineTo(lx2 - Math.cos(perpAngle) * off2, ly2 - Math.sin(perpAngle) * off2);
      ctx.stroke();
    } else {
      // Dashed white
      ctx.strokeStyle = COLORS.laneMarking;
      ctx.lineWidth = 1.5;
      ctx.setLineDash([12, 18]);
      ctx.beginPath();
      ctx.moveTo(lx1, ly1);
      ctx.lineTo(lx2, ly2);
      ctx.stroke();
    }
  }
  ctx.setLineDash([]);
  ctx.restore();
}

function drawSign(ctx, sign, isSelected) {
  const { x, y, signData, rotation = 0, scale = 1 } = sign;
  const s = 28 * scale;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((rotation * Math.PI) / 180);

  if (isSelected) {
    ctx.shadowColor = COLORS.selected;
    ctx.shadowBlur = 12;
  }

  const shape = signData.shape;
  if (shape === "octagon") {
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const a = (Math.PI / 8) + (i * Math.PI) / 4;
      ctx.lineTo(Math.cos(a) * s, Math.sin(a) * s);
    }
    ctx.closePath();
    ctx.fillStyle = signData.color;
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
  } else if (shape === "diamond") {
    ctx.beginPath();
    ctx.moveTo(0, -s);
    ctx.lineTo(s, 0);
    ctx.lineTo(0, s);
    ctx.lineTo(-s, 0);
    ctx.closePath();
    ctx.fillStyle = signData.color;
    ctx.fill();
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.stroke();
  } else if (shape === "triangle") {
    ctx.beginPath();
    ctx.moveTo(0, -s);
    ctx.lineTo(s, s * 0.7);
    ctx.lineTo(-s, s * 0.7);
    ctx.closePath();
    ctx.fillStyle = signData.color;
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
  } else if (shape === "circle") {
    ctx.beginPath();
    ctx.arc(0, 0, s, 0, Math.PI * 2);
    ctx.fillStyle = signData.color;
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
  } else if (shape === "shield") {
    ctx.beginPath();
    ctx.moveTo(-s * 0.7, -s);
    ctx.lineTo(s * 0.7, -s);
    ctx.lineTo(s * 0.8, -s * 0.3);
    ctx.lineTo(0, s);
    ctx.lineTo(-s * 0.8, -s * 0.3);
    ctx.closePath();
    ctx.fillStyle = signData.color;
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
  } else {
    ctx.fillStyle = signData.color || "#fff";
    ctx.strokeStyle = signData.border || "#333";
    ctx.lineWidth = 2;
    ctx.fillRect(-s, -s * 0.65, s * 2, s * 1.3);
    ctx.strokeRect(-s, -s * 0.65, s * 2, s * 1.3);
  }

  // Label
  ctx.fillStyle = signData.textColor || "#fff";
  ctx.font = `bold ${Math.max(9, 11 * scale)}px 'JetBrains Mono', monospace`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const label = signData.label.length > 8 ? signData.label.slice(0, 7) + "‚Ä¶" : signData.label;
  ctx.fillText(label, 0, shape === "triangle" ? 4 : 0);

  ctx.restore();
}

function drawDevice(ctx, device, isSelected) {
  const { x, y, deviceData, rotation = 0 } = device;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((rotation * Math.PI) / 180);

  if (isSelected) {
    ctx.shadowColor = COLORS.selected;
    ctx.shadowBlur = 12;
  }

  ctx.fillStyle = deviceData.color;
  ctx.font = "22px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(deviceData.icon, 0, 0);

  // Label below
  ctx.fillStyle = COLORS.textMuted;
  ctx.font = "9px 'JetBrains Mono', monospace";
  ctx.fillText(deviceData.label, 0, 18);

  ctx.restore();
}

function drawWorkZone(ctx, zone, isSelected) {
  const { x, y, w, h } = zone;
  ctx.save();
  ctx.fillStyle = "rgba(245,158,11,0.08)";
  ctx.strokeStyle = isSelected ? COLORS.selected : "rgba(245,158,11,0.5)";
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 6]);
  ctx.fillRect(x, y, w, h);
  ctx.strokeRect(x, y, w, h);
  ctx.setLineDash([]);

  // Diagonal stripes
  ctx.strokeStyle = "rgba(245,158,11,0.12)";
  ctx.lineWidth = 1;
  for (let i = -Math.max(w, h); i < Math.max(w, h) * 2; i += 20) {
    ctx.beginPath();
    ctx.moveTo(x + i, y);
    ctx.lineTo(x + i + h, y + h);
    ctx.stroke();
  }

  ctx.fillStyle = COLORS.accent;
  ctx.font = "bold 11px 'JetBrains Mono', monospace";
  ctx.textAlign = "center";
  ctx.fillText("WORK ZONE", x + w / 2, y + h / 2);
  ctx.restore();
}

function drawArrow(ctx, arrow, isSelected) {
  const { x1, y1, x2, y2, color = "#fff" } = arrow;
  const angle = angleBetween(x1, y1, x2, y2);
  ctx.save();
  ctx.strokeStyle = isSelected ? COLORS.selected : color;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // Arrowhead
  const headLen = 14;
  ctx.fillStyle = isSelected ? COLORS.selected : color;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLen * Math.cos(angle - 0.4), y2 - headLen * Math.sin(angle - 0.4));
  ctx.lineTo(x2 - headLen * Math.cos(angle + 0.4), y2 - headLen * Math.sin(angle + 0.4));
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawTextLabel(ctx, item, isSelected) {
  ctx.save();
  ctx.fillStyle = isSelected ? COLORS.selected : (item.color || "#fff");
  ctx.font = `${item.bold ? "bold " : ""}${item.fontSize || 14}px 'JetBrains Mono', monospace`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(item.text, item.x, item.y);
  ctx.restore();
}

function drawMeasurement(ctx, m) {
  const d = dist(m.x1, m.y1, m.x2, m.y2);
  const ft = (d * 0.5).toFixed(1);
  const angle = angleBetween(m.x1, m.y1, m.x2, m.y2);
  const midX = (m.x1 + m.x2) / 2;
  const midY = (m.y1 + m.y2) / 2;

  ctx.save();
  ctx.strokeStyle = "#818cf8";
  ctx.lineWidth = 1.5;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(m.x1, m.y1);
  ctx.lineTo(m.x2, m.y2);
  ctx.stroke();
  ctx.setLineDash([]);

  // Endpoints
  [m.x1, m.y1, m.x2, m.y2].forEach((_, i) => {
    if (i % 2 === 0) {
      ctx.beginPath();
      ctx.arc([m.x1, m.x2][i / 2], [m.y1, m.y2][i / 2], 4, 0, Math.PI * 2);
      ctx.fillStyle = "#818cf8";
      ctx.fill();
    }
  });

  // Label
  ctx.fillStyle = "#0f1117";
  ctx.fillRect(midX - 28, midY - 10, 56, 20);
  ctx.fillStyle = "#818cf8";
  ctx.strokeStyle = "#818cf8";
  ctx.lineWidth = 1;
  ctx.strokeRect(midX - 28, midY - 10, 56, 20);
  ctx.font = "bold 10px 'JetBrains Mono', monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(`${ft} ft`, midX, midY);
  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ COMPONENTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function ToolButton({ tool, active, onClick }) {
  return (
    <button
      onClick={onClick}
      title={`${tool.label} (${tool.shortcut})`}
      style={{
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        width: 40,
        height: 40,
        borderRadius: 8,
        border: active ? `2px solid ${COLORS.accent}` : "1px solid transparent",
        background: active ? COLORS.accentDim : "transparent",
        color: active ? COLORS.accent : COLORS.textMuted,
        cursor: "pointer",
        fontSize: 18,
        transition: "all 0.15s",
        position: "relative",
      }}
    >
      <span>{tool.icon}</span>
      <span
        style={{
          position: "absolute",
          bottom: 2,
          right: 3,
          fontSize: 7,
          color: COLORS.textDim,
          fontFamily: "'JetBrains Mono', monospace",
        }}
      >
        {tool.shortcut}
      </span>
    </button>
  );
}

function PropertyPanel({ selected, objects, onUpdate, onDelete }) {
  if (!selected) {
    return (
      <div style={{ padding: 16, color: COLORS.textDim, fontSize: 12, textAlign: "center" }}>
        Select an object to edit its properties
      </div>
    );
  }
  const obj = objects.find((o) => o.id === selected);
  if (!obj) return null;

  return (
    <div style={{ padding: 12 }}>
      <div style={{ fontSize: 11, color: COLORS.accent, textTransform: "uppercase", letterSpacing: 1, marginBottom: 8 }}>
        {obj.type} Properties
      </div>
      {obj.type === "sign" && (
        <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
          <label style={{ fontSize: 11, color: COLORS.textMuted }}>
            Rotation: {obj.rotation || 0}¬∞
            <input
              type="range"
              min="0"
              max="360"
              value={obj.rotation || 0}
              onChange={(e) => onUpdate(obj.id, { rotation: +e.target.value })}
              style={{ width: "100%", accentColor: COLORS.accent }}
            />
          </label>
          <label style={{ fontSize: 11, color: COLORS.textMuted }}>
            Scale: {(obj.scale || 1).toFixed(1)}
            <input
              type="range"
              min="0.5"
              max="3"
              step="0.1"
              value={obj.scale || 1}
              onChange={(e) => onUpdate(obj.id, { scale: +e.target.value })}
              style={{ width: "100%", accentColor: COLORS.accent }}
            />
          </label>
        </div>
      )}
      {obj.type === "device" && (
        <label style={{ fontSize: 11, color: COLORS.textMuted }}>
          Rotation: {obj.rotation || 0}¬∞
          <input
            type="range"
            min="0"
            max="360"
            value={obj.rotation || 0}
            onChange={(e) => onUpdate(obj.id, { rotation: +e.target.value })}
            style={{ width: "100%", accentColor: COLORS.accent }}
          />
        </label>
      )}
      {obj.type === "text" && (
        <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
          <input
            value={obj.text}
            onChange={(e) => onUpdate(obj.id, { text: e.target.value })}
            style={{
              background: COLORS.bg,
              border: `1px solid ${COLORS.panelBorder}`,
              color: COLORS.text,
              padding: "6px 8px",
              borderRadius: 4,
              fontSize: 12,
            }}
          />
          <label style={{ fontSize: 11, color: COLORS.textMuted }}>
            Font Size: {obj.fontSize || 14}
            <input
              type="range"
              min="8"
              max="48"
              value={obj.fontSize || 14}
              onChange={(e) => onUpdate(obj.id, { fontSize: +e.target.value })}
              style={{ width: "100%", accentColor: COLORS.accent }}
            />
          </label>
          <label style={{ fontSize: 11, color: COLORS.textMuted, display: "flex", alignItems: "center", gap: 6 }}>
            <input
              type="checkbox"
              checked={obj.bold || false}
              onChange={(e) => onUpdate(obj.id, { bold: e.target.checked })}
            />
            Bold
          </label>
          <label style={{ fontSize: 11, color: COLORS.textMuted }}>
            Color
            <input
              type="color"
              value={obj.color || "#ffffff"}
              onChange={(e) => onUpdate(obj.id, { color: e.target.value })}
              style={{ width: "100%", height: 24, cursor: "pointer" }}
            />
          </label>
        </div>
      )}
      <button
        onClick={() => onDelete(obj.id)}
        style={{
          marginTop: 12,
          width: "100%",
          padding: "6px 0",
          background: "rgba(239,68,68,0.1)",
          border: "1px solid rgba(239,68,68,0.3)",
          color: COLORS.danger,
          borderRadius: 6,
          cursor: "pointer",
          fontSize: 11,
          fontFamily: "'JetBrains Mono', monospace",
        }}
      >
        Delete Object
      </button>
    </div>
  );
}

function MiniMap({ objects, viewport, canvasSize, zoom, offset }) {
  const ref = useRef(null);
  const mmW = 160;
  const mmH = 100;

  useEffect(() => {
    const cvs = ref.current;
    if (!cvs) return;
    const ctx = cvs.getContext("2d");
    ctx.clearRect(0, 0, mmW, mmH);

    const worldW = 4000;
    const worldH = 3000;
    const sx = mmW / worldW;
    const sy = mmH / worldH;
    const s = Math.min(sx, sy);

    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, mmW, mmH);

    objects.forEach((obj) => {
      if (obj.type === "road") {
        ctx.strokeStyle = COLORS.road;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo((obj.x1 + 2000) * s, (obj.y1 + 1500) * s);
        ctx.lineTo((obj.x2 + 2000) * s, (obj.y2 + 1500) * s);
        ctx.stroke();
      } else if (obj.x !== undefined) {
        ctx.fillStyle = COLORS.accent;
        ctx.fillRect((obj.x + 2000) * s - 1, (obj.y + 1500) * s - 1, 3, 3);
      }
    });

    // Viewport rect
    const vx = (-offset.x / zoom + 2000) * s;
    const vy = (-offset.y / zoom + 1500) * s;
    const vw = (canvasSize.w / zoom) * s;
    const vh = (canvasSize.h / zoom) * s;
    ctx.strokeStyle = COLORS.accent;
    ctx.lineWidth = 1;
    ctx.strokeRect(vx, vy, vw, vh);
  }, [objects, viewport, canvasSize, zoom, offset]);

  return (
    <canvas
      ref={ref}
      width={mmW}
      height={mmH}
      style={{ borderRadius: 6, border: `1px solid ${COLORS.panelBorder}` }}
    />
  );
}

// ‚îÄ‚îÄ‚îÄ MAIN APP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function TrafficControlPlanner() {
  const canvasRef = useRef(null);
  const containerRef = useRef(null);

  // State
  const [tool, setTool] = useState("select");
  const [objects, setObjects] = useState([]);
  const [selected, setSelected] = useState(null);
  const [zoom, setZoom] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [canvasSize, setCanvasSize] = useState({ w: 800, h: 600 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState(null);
  const [drawStart, setDrawStart] = useState(null);
  const [selectedSign, setSelectedSign] = useState(SIGN_CATEGORIES.regulatory.signs[0]);
  const [selectedDevice, setSelectedDevice] = useState(DEVICES[0]);
  const [selectedRoadType, setSelectedRoadType] = useState(ROAD_TYPES[0]);
  const [signCategory, setSignCategory] = useState("regulatory");
  const [leftPanel, setLeftPanel] = useState("tools");
  const [rightPanel, setRightPanel] = useState(true);
  const [showGrid, setShowGrid] = useState(true);
  const [snapEnabled, setSnapEnabled] = useState(true);
  const [history, setHistory] = useState([[]]);
  const [historyIndex, setHistoryIndex] = useState(0);
  const [planTitle, setPlanTitle] = useState("Untitled Traffic Control Plan");
  const [cursorPos, setCursorPos] = useState({ x: 0, y: 0 });
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [searchOpen, setSearchOpen] = useState(false);
  const [searchLoading, setSearchLoading] = useState(false);
  const [searchStatus, setSearchStatus] = useState("");
  const [mapCenter, setMapCenter] = useState(null);
  const [mapRenderTick, setMapRenderTick] = useState(0);
  const mapTileCacheRef = useRef({});

  const mapTiles = useMemo(() => {
    if (!mapCenter) return [];
    const tileSize = 256;
    const zoomLevel = mapCenter.zoom;
    const scale = Math.pow(2, zoomLevel) * tileSize;
    const centerX = ((mapCenter.lon + 180) / 360) * scale;
    const sinLat = Math.sin((mapCenter.lat * Math.PI) / 180);
    const centerY = (0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4 * Math.PI)) * scale;

    const left = centerX - canvasSize.w / 2;
    const top = centerY - canvasSize.h / 2;
    const startTileX = Math.floor(left / tileSize);
    const endTileX = Math.floor((left + canvasSize.w) / tileSize);
    const startTileY = Math.floor(top / tileSize);
    const endTileY = Math.floor((top + canvasSize.h) / tileSize);
    const maxTile = Math.pow(2, zoomLevel);
    const tiles = [];

    for (let ty = startTileY; ty <= endTileY; ty++) {
      if (ty < 0 || ty >= maxTile) continue;
      for (let tx = startTileX; tx <= endTileX; tx++) {
        const wrappedX = ((tx % maxTile) + maxTile) % maxTile;
        const url = `https://tile.openstreetmap.org/${zoomLevel}/${wrappedX}/${ty}.png`;
        tiles.push({
          url,
          x: tx * tileSize - left,
          y: ty * tileSize - top,
          size: tileSize,
        });
      }
    }
    return tiles;
  }, [mapCenter, canvasSize.w, canvasSize.h]);

  useEffect(() => {
    mapTiles.forEach((tile) => {
      if (mapTileCacheRef.current[tile.url]) return;
      const image = new Image();
      image.crossOrigin = "anonymous";
      const entry = { image, loaded: false };
      mapTileCacheRef.current[tile.url] = entry;
      image.onload = () => {
        entry.loaded = true;
        setMapRenderTick((tick) => tick + 1);
      };
      image.onerror = () => {
        delete mapTileCacheRef.current[tile.url];
      };
      image.src = tile.url;
    });
  }, [mapTiles]);

  // Resize observer
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;
    const ro = new ResizeObserver((entries) => {
      for (const e of entries) {
        setCanvasSize({ w: e.contentRect.width, h: e.contentRect.height });
      }
    });
    ro.observe(el);
    return () => ro.disconnect();
  }, []);

  // Push to history
  const pushHistory = useCallback(
    (newObjects) => {
      const newHistory = history.slice(0, historyIndex + 1);
      newHistory.push(newObjects);
      setHistory(newHistory);
      setHistoryIndex(newHistory.length - 1);
    },
    [history, historyIndex]
  );

  const undo = useCallback(() => {
    if (historyIndex > 0) {
      setHistoryIndex(historyIndex - 1);
      setObjects(history[historyIndex - 1]);
      setSelected(null);
    }
  }, [history, historyIndex]);

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      setHistoryIndex(historyIndex + 1);
      setObjects(history[historyIndex + 1]);
      setSelected(null);
    }
  }, [history, historyIndex]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKey = (e) => {
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
      const key = e.key.toUpperCase();
      if (e.metaKey || e.ctrlKey) {
        if (key === "Z" && e.shiftKey) { e.preventDefault(); redo(); return; }
        if (key === "Z") { e.preventDefault(); undo(); return; }
      }
      if (key === "DELETE" || key === "BACKSPACE") {
        if (selected) {
          const newObjs = objects.filter((o) => o.id !== selected);
          setObjects(newObjs);
          pushHistory(newObjs);
          setSelected(null);
        }
        return;
      }
      const t = TOOLS.find((t) => t.shortcut === key);
      if (t) setTool(t.id);
    };
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [selected, objects, undo, redo, pushHistory]);

  // Canvas coords
  const toWorld = useCallback(
    (clientX, clientY) => {
      const rect = canvasRef.current?.getBoundingClientRect();
      if (!rect) return { x: 0, y: 0 };
      let x = (clientX - rect.left - offset.x) / zoom;
      let y = (clientY - rect.top - offset.y) / zoom;
      if (snapEnabled) {
        x = snapToGrid(x, GRID_SIZE);
        y = snapToGrid(y, GRID_SIZE);
      }
      return { x, y };
    },
    [offset, zoom, snapEnabled]
  );

  const hitTest = useCallback(
    (wx, wy) => {
      for (let i = objects.length - 1; i >= 0; i--) {
        const o = objects[i];
        if (o.type === "sign" || o.type === "device" || o.type === "text") {
          if (dist(wx, wy, o.x, o.y) < 30) return o;
        }
        if (o.type === "zone") {
          if (wx >= o.x && wx <= o.x + o.w && wy >= o.y && wy <= o.y + o.h) return o;
        }
        if (o.type === "road" || o.type === "arrow" || o.type === "measure") {
          const d1 = dist(wx, wy, o.x1, o.y1);
          const d2 = dist(wx, wy, o.x2, o.y2);
          const segLen = dist(o.x1, o.y1, o.x2, o.y2);
          if (d1 + d2 < segLen + 20) return o;
        }
      }
      return null;
    },
    [objects]
  );

  // Mouse handlers
  const handleMouseDown = useCallback(
    (e) => {
      const { x, y } = toWorld(e.clientX, e.clientY);
      setCursorPos({ x, y });

      if (tool === "pan" || (e.button === 1) || (e.button === 0 && e.spaceKey)) {
        setIsPanning(true);
        setPanStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
        return;
      }

      if (tool === "select") {
        const hit = hitTest(x, y);
        setSelected(hit ? hit.id : null);
        if (hit) {
          setDrawStart({ x, y, ox: hit.x || hit.x1, oy: hit.y || hit.y1, id: hit.id });
        }
        return;
      }

      if (tool === "erase") {
        const hit = hitTest(x, y);
        if (hit) {
          const newObjs = objects.filter((o) => o.id !== hit.id);
          setObjects(newObjs);
          pushHistory(newObjs);
          setSelected(null);
        }
        return;
      }

      if (tool === "sign") {
        const newSign = { id: uid(), type: "sign", x, y, signData: selectedSign, rotation: 0, scale: 1 };
        const newObjs = [...objects, newSign];
        setObjects(newObjs);
        pushHistory(newObjs);
        setSelected(newSign.id);
        return;
      }

      if (tool === "device") {
        const newDev = { id: uid(), type: "device", x, y, deviceData: selectedDevice, rotation: 0 };
        const newObjs = [...objects, newDev];
        setObjects(newObjs);
        pushHistory(newObjs);
        setSelected(newDev.id);
        return;
      }

      if (tool === "text") {
        const text = prompt("Enter text label:");
        if (text) {
          const newText = { id: uid(), type: "text", x, y, text, fontSize: 14, bold: false, color: "#ffffff" };
          const newObjs = [...objects, newText];
          setObjects(newObjs);
          pushHistory(newObjs);
          setSelected(newText.id);
        }
        return;
      }

      // Start drawing for road, zone, arrow, measure
      if (["road", "zone", "arrow", "measure"].includes(tool)) {
        setDrawStart({ x, y });
      }
    },
    [tool, toWorld, hitTest, offset, objects, selectedSign, selectedDevice, pushHistory]
  );

  const handleMouseMove = useCallback(
    (e) => {
      const { x, y } = toWorld(e.clientX, e.clientY);
      setCursorPos({ x, y });

      if (isPanning && panStart) {
        setOffset({ x: e.clientX - panStart.x, y: e.clientY - panStart.y });
        return;
      }

      if (tool === "select" && drawStart && drawStart.id) {
        const dx = x - drawStart.x;
        const dy = y - drawStart.y;
        setObjects((prev) =>
          prev.map((o) => {
            if (o.id !== drawStart.id) return o;
            if (o.x !== undefined && o.x1 === undefined) {
              return { ...o, x: drawStart.ox + dx, y: drawStart.oy + dy };
            }
            if (o.x1 !== undefined) {
              const segDx = o.x2 - o.x1;
              const segDy = o.y2 - o.y1;
              return { ...o, x1: drawStart.ox + dx, y1: drawStart.oy + dy, x2: drawStart.ox + dx + segDx, y2: drawStart.oy + dy + segDy };
            }
            return o;
          })
        );
      }
    },
    [isPanning, panStart, toWorld, tool, drawStart]
  );

  const handleMouseUp = useCallback(
    (e) => {
      if (isPanning) {
        setIsPanning(false);
        setPanStart(null);
        return;
      }

      if (tool === "select" && drawStart && drawStart.id) {
        pushHistory(objects);
        setDrawStart(null);
        return;
      }

      if (drawStart && ["road", "zone", "arrow", "measure"].includes(tool)) {
        const { x, y } = toWorld(e.clientX, e.clientY);
        const d = dist(drawStart.x, drawStart.y, x, y);
        if (d < 5) { setDrawStart(null); return; }

        let newObj;
        if (tool === "road") {
          newObj = {
            id: uid(), type: "road",
            x1: drawStart.x, y1: drawStart.y, x2: x, y2: y,
            width: selectedRoadType.width, lanes: selectedRoadType.lanes, roadType: selectedRoadType.id,
          };
        } else if (tool === "zone") {
          const zx = Math.min(drawStart.x, x);
          const zy = Math.min(drawStart.y, y);
          newObj = { id: uid(), type: "zone", x: zx, y: zy, w: Math.abs(x - drawStart.x), h: Math.abs(y - drawStart.y) };
        } else if (tool === "arrow") {
          newObj = { id: uid(), type: "arrow", x1: drawStart.x, y1: drawStart.y, x2: x, y2: y, color: "#fff" };
        } else if (tool === "measure") {
          newObj = { id: uid(), type: "measure", x1: drawStart.x, y1: drawStart.y, x2: x, y2: y };
        }

        if (newObj) {
          const newObjs = [...objects, newObj];
          setObjects(newObjs);
          pushHistory(newObjs);
          setSelected(newObj.id);
        }
        setDrawStart(null);
      }
    },
    [isPanning, drawStart, tool, toWorld, objects, selectedRoadType, pushHistory]
  );

  const handleWheel = useCallback(
    (e) => {
      e.preventDefault();
      const rect = canvasRef.current.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      const newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoom * factor));
      const newOx = mx - ((mx - offset.x) / zoom) * newZoom;
      const newOy = my - ((my - offset.y) / zoom) * newZoom;
      setZoom(newZoom);
      setOffset({ x: newOx, y: newOy });
    },
    [zoom, offset]
  );

  // Render canvas
  useEffect(() => {
    const cvs = canvasRef.current;
    if (!cvs) return;
    const ctx = cvs.getContext("2d");
    const dpr = window.devicePixelRatio || 1;
    cvs.width = canvasSize.w * dpr;
    cvs.height = canvasSize.h * dpr;
    ctx.scale(dpr, dpr);

    // Background
    if (mapCenter) {
      ctx.fillStyle = COLORS.canvas;
      ctx.fillRect(0, 0, canvasSize.w, canvasSize.h);
      mapTiles.forEach((tile) => {
        const cached = mapTileCacheRef.current[tile.url];
        if (cached?.loaded) {
          ctx.drawImage(cached.image, tile.x, tile.y, tile.size, tile.size);
        }
      });
      ctx.fillStyle = "rgba(15,17,23,0.18)";
      ctx.fillRect(0, 0, canvasSize.w, canvasSize.h);
    } else {
      ctx.fillStyle = COLORS.canvas;
      ctx.fillRect(0, 0, canvasSize.w, canvasSize.h);
    }

    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(zoom, zoom);

    // Grid
    if (showGrid) {
      const startX = Math.floor(-offset.x / zoom / GRID_SIZE) * GRID_SIZE - GRID_SIZE;
      const startY = Math.floor(-offset.y / zoom / GRID_SIZE) * GRID_SIZE - GRID_SIZE;
      const endX = startX + canvasSize.w / zoom + GRID_SIZE * 2;
      const endY = startY + canvasSize.h / zoom + GRID_SIZE * 2;
      ctx.strokeStyle = COLORS.grid;
      ctx.lineWidth = 0.5;
      for (let x = startX; x < endX; x += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = startY; y < endY; y += GRID_SIZE) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }

    // Draw objects
    objects.forEach((obj) => {
      const isSel = obj.id === selected;
      switch (obj.type) {
        case "road":
          drawRoadSegment(ctx, obj, zoom);
          if (isSel) {
            ctx.strokeStyle = COLORS.selected;
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(obj.x1, obj.y1);
            ctx.lineTo(obj.x2, obj.y2);
            ctx.stroke();
            ctx.setLineDash([]);
          }
          break;
        case "sign":
          drawSign(ctx, obj, isSel);
          break;
        case "device":
          drawDevice(ctx, obj, isSel);
          break;
        case "zone":
          drawWorkZone(ctx, obj, isSel);
          break;
        case "arrow":
          drawArrow(ctx, obj, isSel);
          break;
        case "text":
          drawTextLabel(ctx, obj, isSel);
          break;
        case "measure":
          drawMeasurement(ctx, obj);
          break;
      }
    });

    // Draw preview while dragging
    if (drawStart && ["road", "arrow", "measure", "zone"].includes(tool)) {
      ctx.strokeStyle = "rgba(245,158,11,0.5)";
      ctx.lineWidth = 1;
      ctx.setLineDash([6, 4]);
      if (tool === "zone") {
        const zx = Math.min(drawStart.x, cursorPos.x);
        const zy = Math.min(drawStart.y, cursorPos.y);
        ctx.strokeRect(zx, zy, Math.abs(cursorPos.x - drawStart.x), Math.abs(cursorPos.y - drawStart.y));
      } else {
        ctx.beginPath();
        ctx.moveTo(drawStart.x, drawStart.y);
        ctx.lineTo(cursorPos.x, cursorPos.y);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    ctx.restore();
  }, [objects, selected, zoom, offset, canvasSize, showGrid, tool, drawStart, cursorPos, mapCenter, mapTiles, mapRenderTick]);

  // Update object
  const updateObject = (id, updates) => {
    const newObjs = objects.map((o) => (o.id === id ? { ...o, ...updates } : o));
    setObjects(newObjs);
    pushHistory(newObjs);
  };

  const deleteObject = (id) => {
    const newObjs = objects.filter((o) => o.id !== id);
    setObjects(newObjs);
    pushHistory(newObjs);
    setSelected(null);
  };

  const clearAll = () => {
    if (confirm("Clear all objects?")) {
      setObjects([]);
      pushHistory([]);
      setSelected(null);
    }
  };

  const zoomIn = () => setZoom((z) => Math.min(MAX_ZOOM, z * 1.2));
  const zoomOut = () => setZoom((z) => Math.max(MIN_ZOOM, z / 1.2));
  const zoomFit = () => { setZoom(1); setOffset({ x: 0, y: 0 }); };

  const doAddressSearch = async () => {
    if (!searchQuery.trim()) return;
    setSearchLoading(true);
    setSearchStatus("");
    try {
      const results = await geocodeAddress(searchQuery);
      setSearchResults(results);
      setSearchOpen(true);
      if (!results.length) {
        setSearchStatus("No matches found.");
        return;
      }
      selectAddressResult(results[0]);
    } catch {
      setSearchStatus("Address lookup failed. Try again.");
      setSearchResults([]);
      setSearchOpen(true);
    } finally {
      setSearchLoading(false);
    }
  };

  const selectAddressResult = (result) => {
    setSearchQuery(formatSearchPrimary(result));
    const lat = Number(result?.lat);
    const lon = Number(result?.lon);
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      setMapCenter({ lat, lon, zoom: 16 });
      setOffset({ x: 0, y: 0 });
      setZoom(1);
      setSearchStatus(`Centered on ${formatSearchPrimary(result)}`);
    } else {
      setSearchStatus("Selected result has no coordinates.");
    }
    setSearchOpen(false);
  };

  const panelBtnStyle = (active) => ({
    padding: "6px 10px",
    fontSize: 10,
    fontFamily: "'JetBrains Mono', monospace",
    background: active ? COLORS.accentDim : "transparent",
    color: active ? COLORS.accent : COLORS.textMuted,
    border: active ? `1px solid ${COLORS.accent}` : `1px solid ${COLORS.panelBorder}`,
    borderRadius: 5,
    cursor: "pointer",
    transition: "all 0.15s",
  });

  const sectionTitle = (text) => (
    <div style={{ fontSize: 10, color: COLORS.textDim, textTransform: "uppercase", letterSpacing: 1.5, marginBottom: 6, marginTop: 12, fontFamily: "'JetBrains Mono', monospace" }}>
      {text}
    </div>
  );

  const isSearchError = searchStatus.startsWith("Address lookup failed")
    || searchStatus.startsWith("No matches")
    || searchStatus.startsWith("Selected result");

  return (
    <div
      style={{
        width: "100%",
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        background: COLORS.bg,
        color: COLORS.text,
        fontFamily: "'JetBrains Mono', 'SF Mono', 'Fira Code', monospace",
        overflow: "hidden",
        userSelect: "none",
      }}
    >
      <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet" />

      {/* ‚îÄ‚îÄ‚îÄ TOP BAR ‚îÄ‚îÄ‚îÄ */}
      <div
        style={{
          height: 48,
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          padding: "0 16px",
          borderBottom: `1px solid ${COLORS.panelBorder}`,
          background: COLORS.panel,
          flexShrink: 0,
          gap: 12,
        }}
      >
        <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
          <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
            <span style={{ fontSize: 20, color: COLORS.accent }}>‚óÜ</span>
            <span style={{ fontSize: 13, fontWeight: 700, color: COLORS.accent, letterSpacing: 1 }}>TCP</span>
          </div>
          <div style={{ width: 1, height: 24, background: COLORS.panelBorder }} />
          <input
            value={planTitle}
            onChange={(e) => setPlanTitle(e.target.value)}
            style={{
              background: "transparent",
              border: "none",
              color: COLORS.text,
              fontSize: 13,
              fontWeight: 500,
              width: 280,
              padding: "4px 8px",
              borderRadius: 4,
              fontFamily: "inherit",
            }}
          />
        </div>
        <div style={{ position: "relative", flex: "0 1 420px" }}>
          <div style={{ display: "flex", gap: 6 }}>
            <input
              value={searchQuery}
              onChange={(e) => { setSearchQuery(e.target.value); setSearchStatus(""); }}
              onKeyDown={(e) => e.key === "Enter" && doAddressSearch()}
              placeholder="Search address‚Ä¶"
              style={{
                flex: 1,
                padding: "5px 10px",
                fontSize: 11,
                background: COLORS.bg,
                border: `1px solid ${COLORS.panelBorder}`,
                color: COLORS.text,
                borderRadius: 5,
                fontFamily: "inherit",
                outline: "none",
              }}
            />
            <button
              onClick={doAddressSearch}
              style={{
                ...panelBtnStyle(false),
                background: COLORS.accentDim,
                color: COLORS.accent,
                borderColor: "rgba(245,158,11,0.35)",
                whiteSpace: "nowrap",
              }}
            >
              {searchLoading ? "‚Ä¶" : "üîç Go"}
            </button>
          </div>
          {searchStatus && (
            <div style={{ marginTop: 4, fontSize: 9, color: isSearchError ? COLORS.danger : COLORS.textDim }}>
              {searchStatus}
            </div>
          )}
          {searchOpen && searchResults.length > 0 && (
            <div
              style={{
                position: "absolute",
                top: 34,
                left: 0,
                right: 0,
                background: COLORS.panel,
                border: `1px solid ${COLORS.panelBorder}`,
                borderRadius: 6,
                zIndex: 999,
                maxHeight: 240,
                overflow: "auto",
                boxShadow: "0 8px 32px rgba(0,0,0,0.45)",
              }}
            >
              {searchResults.map((result, index) => (
                <div
                  key={index}
                  onClick={() => selectAddressResult(result)}
                  style={{
                    padding: "7px 12px",
                    fontSize: 10,
                    color: COLORS.text,
                    cursor: "pointer",
                    borderBottom: `1px solid ${COLORS.panelBorder}`,
                  }}
                  onMouseEnter={(e) => { e.currentTarget.style.background = COLORS.accentDim; }}
                  onMouseLeave={(e) => { e.currentTarget.style.background = "transparent"; }}
                >
                  <div style={{ fontWeight: 500 }}>{formatSearchPrimary(result)}</div>
                  <div style={{ fontSize: 8, color: COLORS.textDim, marginTop: 1 }}>{result.display_name}</div>
                </div>
              ))}
              <div
                onClick={() => setSearchOpen(false)}
                style={{ padding: "5px", fontSize: 9, color: COLORS.textDim, cursor: "pointer", textAlign: "center" }}
              >
                Hide results
              </div>
            </div>
          )}
        </div>
        <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
          <button onClick={undo} style={panelBtnStyle(false)} title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
          <button onClick={redo} style={panelBtnStyle(false)} title="Redo (Ctrl+Shift+Z)">‚Ü∑ Redo</button>
          <div style={{ width: 1, height: 20, background: COLORS.panelBorder }} />
          <button onClick={clearAll} style={{ ...panelBtnStyle(false), color: COLORS.danger, borderColor: "rgba(239,68,68,0.3)" }}>
            Clear All
          </button>
        </div>
      </div>

      <div style={{ display: "flex", flex: 1, overflow: "hidden" }}>
        {/* ‚îÄ‚îÄ‚îÄ LEFT PANEL ‚îÄ‚îÄ‚îÄ */}
        <div
          style={{
            width: 260,
            background: COLORS.panel,
            borderRight: `1px solid ${COLORS.panelBorder}`,
            display: "flex",
            flexDirection: "column",
            flexShrink: 0,
            overflow: "hidden",
          }}
        >
          {/* Panel tabs */}
          <div style={{ display: "flex", borderBottom: `1px solid ${COLORS.panelBorder}` }}>
            {["tools", "signs", "devices", "roads"].map((tab) => (
              <button
                key={tab}
                onClick={() => setLeftPanel(tab)}
                style={{
                  flex: 1,
                  padding: "8px 0",
                  fontSize: 9,
                  textTransform: "uppercase",
                  letterSpacing: 1,
                  background: leftPanel === tab ? COLORS.accentDim : "transparent",
                  color: leftPanel === tab ? COLORS.accent : COLORS.textDim,
                  border: "none",
                  borderBottom: leftPanel === tab ? `2px solid ${COLORS.accent}` : "2px solid transparent",
                  cursor: "pointer",
                  fontFamily: "inherit",
                }}
              >
                {tab}
              </button>
            ))}
          </div>

          <div style={{ flex: 1, overflow: "auto", padding: 12 }}>
            {/* TOOLS TAB */}
            {leftPanel === "tools" && (
              <>
                {sectionTitle("Drawing Tools")}
                <div style={{ display: "grid", gridTemplateColumns: "repeat(5, 1fr)", gap: 4 }}>
                  {TOOLS.map((t) => (
                    <ToolButton key={t.id} tool={t} active={tool === t.id} onClick={() => setTool(t.id)} />
                  ))}
                </div>

                {sectionTitle("Canvas")}
                <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
                  <label style={{ display: "flex", alignItems: "center", gap: 8, fontSize: 11, color: COLORS.textMuted, cursor: "pointer" }}>
                    <input type="checkbox" checked={showGrid} onChange={(e) => setShowGrid(e.target.checked)} style={{ accentColor: COLORS.accent }} />
                    Show Grid
                  </label>
                  <label style={{ display: "flex", alignItems: "center", gap: 8, fontSize: 11, color: COLORS.textMuted, cursor: "pointer" }}>
                    <input type="checkbox" checked={snapEnabled} onChange={(e) => setSnapEnabled(e.target.checked)} style={{ accentColor: COLORS.accent }} />
                    Snap to Grid
                  </label>
                </div>

                {sectionTitle("Zoom")}
                <div style={{ display: "flex", gap: 4 }}>
                  <button onClick={zoomOut} style={panelBtnStyle(false)}>‚àí</button>
                  <div style={{ flex: 1, textAlign: "center", fontSize: 11, color: COLORS.text, lineHeight: "28px" }}>
                    {(zoom * 100).toFixed(0)}%
                  </div>
                  <button onClick={zoomIn} style={panelBtnStyle(false)}>+</button>
                  <button onClick={zoomFit} style={panelBtnStyle(false)}>Fit</button>
                </div>

                {sectionTitle("Objects")}
                <div style={{ fontSize: 11, color: COLORS.textMuted }}>
                  {objects.length} objects on canvas
                </div>

                {sectionTitle("Mini Map")}
                <MiniMap objects={objects} viewport={{}} canvasSize={canvasSize} zoom={zoom} offset={offset} />
              </>
            )}

            {/* SIGNS TAB */}
            {leftPanel === "signs" && (
              <>
                {sectionTitle("Sign Category")}
                <div style={{ display: "flex", flexWrap: "wrap", gap: 4, marginBottom: 8 }}>
                  {Object.entries(SIGN_CATEGORIES).map(([key, cat]) => (
                    <button
                      key={key}
                      onClick={() => setSignCategory(key)}
                      style={{
                        ...panelBtnStyle(signCategory === key),
                        borderColor: signCategory === key ? cat.color : COLORS.panelBorder,
                        color: signCategory === key ? cat.color : COLORS.textMuted,
                        background: signCategory === key ? `${cat.color}15` : "transparent",
                      }}
                    >
                      {cat.label}
                    </button>
                  ))}
                </div>

                {sectionTitle("Signs")}
                <div style={{ display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: 6 }}>
                  {SIGN_CATEGORIES[signCategory].signs.map((sign) => (
                    <button
                      key={sign.id}
                      onClick={() => { setSelectedSign(sign); setTool("sign"); }}
                      style={{
                        padding: "10px 6px",
                        background: selectedSign?.id === sign.id && tool === "sign" ? COLORS.accentDim : "rgba(255,255,255,0.03)",
                        border: selectedSign?.id === sign.id && tool === "sign" ? `1px solid ${COLORS.accent}` : `1px solid ${COLORS.panelBorder}`,
                        borderRadius: 6,
                        cursor: "pointer",
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        gap: 4,
                      }}
                    >
                      <div
                        style={{
                          width: 28,
                          height: 28,
                          borderRadius: sign.shape === "circle" ? "50%" : sign.shape === "diamond" ? 0 : 4,
                          background: sign.color,
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontSize: 9,
                          fontWeight: 700,
                          color: sign.textColor,
                          border: sign.border ? `2px solid ${sign.border}` : "none",
                          transform: sign.shape === "diamond" ? "rotate(45deg)" : "none",
                        }}
                      >
                        <span style={{ transform: sign.shape === "diamond" ? "rotate(-45deg)" : "none", fontSize: 8 }}>
                          {sign.label.slice(0, 3)}
                        </span>
                      </div>
                      <span style={{ fontSize: 8, color: COLORS.textMuted, textAlign: "center" }}>{sign.label}</span>
                    </button>
                  ))}
                </div>
                <div style={{ marginTop: 12, padding: 8, background: "rgba(245,158,11,0.05)", borderRadius: 6, border: `1px solid rgba(245,158,11,0.1)` }}>
                  <div style={{ fontSize: 9, color: COLORS.accent }}>Tip: Select a sign then click on the canvas to place it.</div>
                </div>
              </>
            )}

            {/* DEVICES TAB */}
            {leftPanel === "devices" && (
              <>
                {sectionTitle("Traffic Devices")}
                <div style={{ display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: 6 }}>
                  {DEVICES.map((dev) => (
                    <button
                      key={dev.id}
                      onClick={() => { setSelectedDevice(dev); setTool("device"); }}
                      style={{
                        padding: "10px 6px",
                        background: selectedDevice?.id === dev.id && tool === "device" ? COLORS.accentDim : "rgba(255,255,255,0.03)",
                        border: selectedDevice?.id === dev.id && tool === "device" ? `1px solid ${COLORS.accent}` : `1px solid ${COLORS.panelBorder}`,
                        borderRadius: 6,
                        cursor: "pointer",
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        gap: 4,
                      }}
                    >
                      <span style={{ fontSize: 20 }}>{dev.icon}</span>
                      <span style={{ fontSize: 8, color: COLORS.textMuted }}>{dev.label}</span>
                    </button>
                  ))}
                </div>
              </>
            )}

            {/* ROADS TAB */}
            {leftPanel === "roads" && (
              <>
                {sectionTitle("Road Types")}
                <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
                  {ROAD_TYPES.map((rt) => (
                    <button
                      key={rt.id}
                      onClick={() => { setSelectedRoadType(rt); setTool("road"); }}
                      style={{
                        padding: "10px 12px",
                        background: selectedRoadType?.id === rt.id && tool === "road" ? COLORS.accentDim : "rgba(255,255,255,0.03)",
                        border: selectedRoadType?.id === rt.id && tool === "road" ? `1px solid ${COLORS.accent}` : `1px solid ${COLORS.panelBorder}`,
                        borderRadius: 6,
                        cursor: "pointer",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "space-between",
                        textAlign: "left",
                      }}
                    >
                      <div>
                        <div style={{ fontSize: 11, color: COLORS.text, fontWeight: 500 }}>{rt.label}</div>
                        <div style={{ fontSize: 9, color: COLORS.textDim }}>{rt.lanes} lanes ‚Ä¢ {rt.width}px width</div>
                      </div>
                      <div style={{ display: "flex", gap: 2 }}>
                        {Array(rt.lanes).fill(0).map((_, i) => (
                          <div key={i} style={{ width: 4, height: 20, background: COLORS.road, borderRadius: 1, border: `1px solid ${COLORS.panelBorder}` }} />
                        ))}
                      </div>
                    </button>
                  ))}
                </div>
                <div style={{ marginTop: 12, padding: 8, background: "rgba(245,158,11,0.05)", borderRadius: 6, border: `1px solid rgba(245,158,11,0.1)` }}>
                  <div style={{ fontSize: 9, color: COLORS.accent }}>Tip: Click and drag on the canvas to draw a road segment.</div>
                </div>
              </>
            )}
          </div>
        </div>

        {/* ‚îÄ‚îÄ‚îÄ CANVAS ‚îÄ‚îÄ‚îÄ */}
        <div ref={containerRef} style={{ flex: 1, position: "relative", overflow: "hidden" }}>
          <canvas
            ref={canvasRef}
            style={{
              width: canvasSize.w,
              height: canvasSize.h,
              cursor:
                tool === "pan" || isPanning ? "grab" :
                tool === "erase" ? "crosshair" :
                tool === "select" ? "default" :
                "crosshair",
            }}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={() => { setIsPanning(false); setPanStart(null); }}
            onWheel={handleWheel}
          />

          {/* Status bar */}
          <div
            style={{
              position: "absolute",
              bottom: 0,
              left: 0,
              right: 0,
              height: 28,
              background: COLORS.panel,
              borderTop: `1px solid ${COLORS.panelBorder}`,
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              padding: "0 12px",
              fontSize: 10,
              color: COLORS.textDim,
            }}
          >
            <div style={{ display: "flex", gap: 16 }}>
              <span>X: {cursorPos.x.toFixed(0)}</span>
              <span>Y: {cursorPos.y.toFixed(0)}</span>
              <span>Zoom: {(zoom * 100).toFixed(0)}%</span>
            </div>
            <div style={{ display: "flex", gap: 16 }}>
              <span>{objects.length} objects</span>
              <span>Tool: {tool.toUpperCase()}</span>
              <span>{showGrid ? "Grid ON" : "Grid OFF"}</span>
              <span>{snapEnabled ? "Snap ON" : "Snap OFF"}</span>
            </div>
          </div>
        </div>

        {/* ‚îÄ‚îÄ‚îÄ RIGHT PANEL ‚îÄ‚îÄ‚îÄ */}
        {rightPanel && (
          <div
            style={{
              width: 220,
              background: COLORS.panel,
              borderLeft: `1px solid ${COLORS.panelBorder}`,
              display: "flex",
              flexDirection: "column",
              flexShrink: 0,
            }}
          >
            <div
              style={{
                padding: "10px 12px",
                borderBottom: `1px solid ${COLORS.panelBorder}`,
                fontSize: 10,
                textTransform: "uppercase",
                letterSpacing: 1.5,
                color: COLORS.textDim,
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
              }}
            >
              Properties
              <button onClick={() => setRightPanel(false)} style={{ background: "none", border: "none", color: COLORS.textDim, cursor: "pointer", fontSize: 14 }}>√ó</button>
            </div>
            <PropertyPanel selected={selected} objects={objects} onUpdate={updateObject} onDelete={deleteObject} />

            <div style={{ marginTop: "auto", borderTop: `1px solid ${COLORS.panelBorder}`, padding: 12 }}>
              {sectionTitle("Layers")}
              <div style={{ display: "flex", flexDirection: "column", gap: 2, maxHeight: 200, overflow: "auto" }}>
                {objects.length === 0 && (
                  <div style={{ fontSize: 10, color: COLORS.textDim, textAlign: "center", padding: 12 }}>No objects yet</div>
                )}
                {[...objects].reverse().map((obj) => (
                  <div
                    key={obj.id}
                    onClick={() => setSelected(obj.id)}
                    style={{
                      padding: "5px 8px",
                      borderRadius: 4,
                      fontSize: 10,
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      gap: 6,
                      background: selected === obj.id ? COLORS.accentDim : "transparent",
                      color: selected === obj.id ? COLORS.accent : COLORS.textMuted,
                      border: selected === obj.id ? `1px solid rgba(245,158,11,0.2)` : "1px solid transparent",
                    }}
                  >
                    <span style={{ fontSize: 12 }}>
                      {obj.type === "road" ? "‚îÅ" : obj.type === "sign" ? "‚¨°" : obj.type === "device" ? "‚ñ≤" : obj.type === "zone" ? "‚ñ®" : obj.type === "arrow" ? "‚Üí" : obj.type === "text" ? "T" : "üìè"}
                    </span>
                    <span>
                      {obj.type === "sign" ? obj.signData.label :
                       obj.type === "device" ? obj.deviceData.label :
                       obj.type === "text" ? `"${obj.text.slice(0, 12)}"` :
                       obj.type === "road" ? `${obj.roadType} road` :
                       obj.type}
                    </span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}
        {!rightPanel && (
          <button
            onClick={() => setRightPanel(true)}
            style={{
              position: "absolute",
              top: 60,
              right: 12,
              ...panelBtnStyle(false),
              background: COLORS.panel,
            }}
          >
            ‚óÄ Props
          </button>
        )}
      </div>
    </div>
  );
}

// Mount
document.getElementById("loading").style.opacity = "0";
setTimeout(() => document.getElementById("loading").style.display = "none", 300);
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<TrafficControlPlanner />);
</script>
</body>
</html>
